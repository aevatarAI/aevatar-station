name: Update Aevatar Station Ephemeral Test Environment

on:
  workflow_dispatch:
    inputs:
      project_name:
        description: "Project name"
        required: true
      service:
        description: "Service name"
        required: true
        type: choice
        options:
          - All 
          - Aevatar.Silo
          - Aevatar.HttpApi.Host
          - Aevatar.AuthServer
          - Aevatar.DbMigrator
          - Aevatar.Developer.Host
          - Aevatar.Developer.Silo

run-name: Update Aevatar Station Ephemeral Test Environment Image on ${{ github.ref_name }} from ${{ github.sha }}

env:
  DOTNET_INSTALL_DIR: "./.dotnet"

jobs:
  set-matrix-and-namespace:
    runs-on: ephemeral-env-runner
    outputs:
      matrix: ${{ steps.set-matrix-and-namespace.outputs.matrix }}
      namespace: ${{ steps.namespace.outputs.namespace }}
    steps:
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Set matrix
        id: set-matrix-and-namespace
        run: |
          # Set matrix based on service input
          service="${{ github.event.inputs.service }}"
          if [[ "$service" == "All" ]]; then
            matrix=$(jq -c -n '[
              "Aevatar.Silo",
              "Aevatar.Developer.Host",
              "Aevatar.Developer.Silo",
              "Aevatar.HttpApi.Host",
              "Aevatar.AuthServer",
              "Aevatar.DbMigrator"
            ]')
          elif [[ "$service" == "Aevatar.Silo" ]]; then
            matrix=$(jq -c -n '["Aevatar.Silo"]')
          elif [[ "$service" == "Aevatar.Developer.Host" ]]; then
            matrix=$(jq -c -n '["Aevatar.Developer.Host"]')
          elif [[ "$service" == "Aevatar.Developer.Silo" ]]; then
            matrix=$(jq -c -n '["Aevatar.Developer.Silo"]')
          elif [[ "$service" == "Aevatar.HttpApi.Host" ]]; then
            matrix=$(jq -c -n '["Aevatar.HttpApi.Host"]')
          elif [[ "$service" == "Aevatar.AuthServer" ]]; then
            matrix=$(jq -c -n '["Aevatar.AuthServer"]')
          elif [[ "$service" == "Aevatar.DbMigrator" ]]; then
            matrix=$(jq -c -n '["Aevatar.DbMigrator"]')
          else
            echo "Invalid service input"
            exit 1
          fi

          echo "matrix=$matrix" >> "$GITHUB_OUTPUT"

      - name: Set Namespace
        id: namespace
        run: |
          NAMESPACE="${{ github.event.inputs.namespace }}"
          if [[ -z "$NAMESPACE" ]]; then
            PROJECT_NAME="${{ github.event.inputs.project_name }}"
            # Strip all spaces from project_name
            PROJECT_NAME_NO_SPACES="${PROJECT_NAME// /}"
            NAMESPACE="${PROJECT_NAME_NO_SPACES}-ephemeral-test-1"
          fi
          echo "namespace=$NAMESPACE" >> "$GITHUB_OUTPUT"

  publish:
    runs-on: ephemeral-env-runner
    needs: set-matrix-and-namespace
    strategy:
      matrix:
        servicename: ${{ fromJson(needs.set-matrix-and-namespace.outputs.matrix) }}
    steps:
      # Checkout source code
      - name: Checkout code
        uses: actions/checkout@v3

      # Set up .NET 9 SDK
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '9.0.x'
          
      # Cache NuGet packages to speed up builds
      - name: Cache NuGet Packages
        id: nuget-packages
        uses: actions/cache@v4
        env:
          cache-name: nuget-package-cache
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-${{ env.cache-name }}-${{ matrix.servicename }}

      # Publish .NET project
      - name: Publish .NET project      
        run: |
          # For Developer.Silo, use the regular Silo project but publish to Developer.Silo output directory
          if [[ "${{ matrix.servicename }}" == "Aevatar.Developer.Silo" ]]; then
            dotnet publish station/src/Aevatar.Silo/Aevatar.Silo.csproj -o out/${{ matrix.servicename }}
          else
            dotnet publish station/src/${{ matrix.servicename }}/${{ matrix.servicename }}.csproj -o out/${{ matrix.servicename }}
          fi
      
      # Upload build artifacts for the next job
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.servicename }}
          path: out/${{ matrix.servicename }}
          retention-days: 1

  build-and-push-image:
    needs: [set-matrix-and-namespace, publish]
    runs-on: ephemeral-env-runner
    strategy:
      matrix:
        servicename: ${{ fromJson(needs.set-matrix-and-namespace.outputs.matrix) }}
    permissions:
      contents: read
    outputs:
      short_sha: ${{ steps.vars.outputs.short_sha }}
    steps:
      # Checkout code (used for Docker build context)
      - name: Checkout
        uses: actions/checkout@v4

      # Extract short SHA for versioning
      - name: Set short git commit SHA
        id: vars
        run: |
          calculatedSha=$(git rev-parse --short ${{ github.sha }})
          echo "short_sha=$calculatedSha" >> "$GITHUB_OUTPUT"

      # Download published build artifact
      - name: Download a single artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.servicename }}
          path: out/${{ matrix.servicename }}

      # Generate image tag metadata
      - name: Create image tag
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.REPOSITORY_REGION }}-docker.pkg.dev/${{ secrets.PROJECT_ID }}/${{ secrets.REPOSITORY }}/${{ matrix.servicename }}
          tags: |
            type=sha

      # Setup Docker Buildx (multi-platform builds & cache support)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          version: latest

      # Build and push Docker image
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          build-args: |
            servicename=${{ matrix.servicename }}
          platforms: linux/amd64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Install Cosign CLI for signing
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.5.0

      # Install Crane to get image digest
      - name: Install Crane (for digest lookup)
        run: |
          curl -sSL https://github.com/google/go-containerregistry/releases/latest/download/go-containerregistry_Linux_x86_64.tar.gz -o crane.tar.gz
          sudo tar -xzvf crane.tar.gz -C /usr/local/bin crane
    
      # Extract image digest from registry
      - name: Extract image digest
        id: digest
        run: |
          DIGEST=$(crane digest "${{ steps.meta.outputs.tags }}")
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      # Sign image digest using Cosign
      - name: Cosign sign image
        env:
          COSIGN_EXPERIMENTAL: "1"
          COSIGN_YES: "true"
        run: |
          cosign sign "${{ steps.meta.outputs.tags }}@${{ steps.digest.outputs.digest }}"

  update-ephemeral-test-env-image:
    runs-on: ephemeral-env-runner
    needs: [set-matrix-and-namespace, build-and-push-image]
    steps:
      # Checkout code
      - name: Checkout code
        uses: actions/checkout@v3

      # Set up kubectl
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      # Configure Kubernetes credentials
      - name: Configure Kubernetes credentials
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG }}

      # Save admin kubeconfig
      - name: Save admin kubeconfig
        id: admin-kubeconfig
        run: |
          # Save the admin kubeconfig to a file
          ADMIN_KUBECONFIG=$(mktemp)
          echo "${{ secrets.KUBE_CONFIG }}" > $ADMIN_KUBECONFIG
          chmod 600 $ADMIN_KUBECONFIG
          echo "ADMIN_KUBECONFIG=$ADMIN_KUBECONFIG" >> $GITHUB_OUTPUT

      # Validate namespace
      - name: Validate namespace 
        run: |
          # Check if namespace exists
          echo "Checking if we can list namespaces..."
          kubectl get namespace ${{ needs.set-matrix-and-namespace.outputs.namespace }} > /dev/null || { echo "Error: Cannot list ${{ needs.set-matrix-and-namespace.outputs.namespace }}. Please ensure the the namespace exists"; exit 1; }
          echo "Namespace ${{ needs.set-matrix-and-namespace.outputs.namespace }} exists"
     
      # Update ephemeral-test-env image
      - name: Update ephemeral-test-env image
        run: |
          # Update the ephemeral-test-env image
          NS="${{ needs.set-matrix-and-namespace.outputs.namespace }}"
          IMAGE_TAG="sha-${{ needs.build-and-push-image.outputs.short_sha }}"
          SERVICE="${{ github.event.inputs.service }}"
          PROJECT_RAW="${{ github.event.inputs.project_name }}"
          PROJECT="${PROJECT_RAW// /}"
          SUMMARY_FILE="$GITHUB_STEP_SUMMARY"
          
          # Generate client ID and URLs based on project name
          if [[ "$PROJECT" == "env-"* ]]; then
            CLIENT_ID="${PROJECT#env-}"
            AUTH_SERVER_URL="http://${PROJECT}.auth-station-testing.aevatar.ai"
            API_SERVER_URL="http://${PROJECT}.station-testing.aevatar.ai"
            
            echo "ℹ️ Configuration:"
            echo "  - Project: $PROJECT"
            echo "  - Client ID: $CLIENT_ID"
            echo "  - Auth Server: $AUTH_SERVER_URL"
            echo "  - API Server: $API_SERVER_URL"
          else
            echo "::error ::❌ Project name must start with 'env-'"
            echo "- ❌ Invalid project name: \`$PROJECT\` (must start with 'env-')" >> "$SUMMARY_FILE"
            exit 1
          fi

          update_deployment_if_exists() {
            local deployment="$1"
            if kubectl get deployment "$deployment" -n "$NS" > /dev/null 2>&1; then
              echo "🔄 Updating deployment $deployment"
              CURRENT_IMAGE=$(kubectl get deployment "$deployment" -n "$NS" -o jsonpath="{.spec.template.spec.containers[0].image}")
              BASE_IMAGE="${CURRENT_IMAGE%%[@:]*}"
              NEW_IMAGE="${BASE_IMAGE}:${IMAGE_TAG}"

              if ! kubectl patch deployment "$deployment" -n "$NS" --type=json -p="[
                { \"op\": \"replace\", \"path\": \"/spec/template/spec/containers/0/image\", \"value\": \"$NEW_IMAGE\" }
              ]"; then
                echo "::error ::❌ Failed to patch deployment $deployment"
                echo "- ❌ \`$deployment\`: Failed to patch image" >> "$SUMMARY_FILE"
                exit 1
              fi

              if ! kubectl rollout status deployment "$deployment" -n "$NS" --timeout=300s; then
                echo "::error ::❌ Rollout failed for deployment $deployment"
                echo "- ❌ \`$deployment\`: Rollout failed" >> "$SUMMARY_FILE"
                exit 1
              fi

              echo "::notice ::✅ Deployment $deployment updated to $NEW_IMAGE"
              echo "- ✅ \`$deployment\`: Updated to \`$NEW_IMAGE\`" >> "$SUMMARY_FILE"
            else
              echo "::warning ::⚠️ Deployment $deployment not found"
              echo "- ⚠️ \`$deployment\`: Not found" >> "$SUMMARY_FILE"
            fi
          }

          update_job_if_exists() {
            local job_name="$1"
            local run_command="$2"
            if kubectl get job "$job_name" -n "$NS" > /dev/null 2>&1; then
              CURRENT_IMAGE=$(kubectl get job "$job_name" -n "$NS" -o jsonpath="{.spec.template.spec.containers[0].image}")
              BASE_IMAGE="${CURRENT_IMAGE%%[@:]*}"
              NEW_IMAGE="${BASE_IMAGE}:${IMAGE_TAG}"
            fi

            echo "🔄 Updating job $job_name to $NEW_IMAGE"
            kubectl delete job "$job_name" -n "$NS" --ignore-not-found

            if ! kubectl create job "$job_name" --image="$NEW_IMAGE" -n "$NS" -- /bin/bash -c "$run_command"; then
              echo "::error ::❌ Failed to create job $job_name"
              echo "- ❌ \`$job_name\`: Failed to create" >> "$SUMMARY_FILE"
              exit 1
            fi

            echo "::notice ::✅ Job $job_name created with image $NEW_IMAGE"
            echo "- ✅ \`$job_name\`: Created with \`$NEW_IMAGE\`" >> "$SUMMARY_FILE"
          }

          get_auth_token() {
            echo "🔐 Getting authentication token from $AUTH_SERVER_URL"
            echo "ℹ️ Using client_id: $CLIENT_ID"
            
            TOKEN_RESPONSE=$(curl -s -k -X POST "${AUTH_SERVER_URL}/connect/token" \
              -H 'Content-Type: application/x-www-form-urlencoded' \
              -H 'Accept: application/json' \
              --data-urlencode 'grant_type=client_credentials' \
              --data-urlencode "client_id=${CLIENT_ID}" \
              --data-urlencode "client_secret=${CLIENT_ID}" \
              --data-urlencode 'scope=Aevatar')
            
            if [[ $? -ne 0 ]]; then
              echo "::error ::❌ Failed to get authentication token"
              echo "- ❌ Authentication: Failed to get token from \`$AUTH_SERVER_URL\`" >> "$SUMMARY_FILE"
              exit 1
            fi
            
            echo "ℹ️ Auth server response: $TOKEN_RESPONSE"
            
            TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.access_token')
            
            if [[ "$TOKEN" == "null" || -z "$TOKEN" ]]; then
              echo "::error ::❌ Invalid token response"
              echo "ℹ️ Token extracted: '$TOKEN'"
              echo "- ❌ Authentication: Invalid token response" >> "$SUMMARY_FILE"
              exit 1
            fi
            
            echo "✅ Authentication token obtained successfully"
            echo "ℹ️ Token length: ${#TOKEN} characters"
            echo "$TOKEN"
          }


          update_image_via_api() {
            local host_type="$1"
            local image_name="$2"
            local service_name="$3"
            
            echo "🔄 Updating $service_name via API (hostType=$host_type)"
            echo "ℹ️ Image name: $image_name"
            echo "ℹ️ API Server URL: $API_SERVER_URL"
            
            # Get authentication token
            AUTH_TOKEN=$(get_auth_token)
            
            # Test multiple API endpoints to find working ones
            echo "ℹ️ Testing available API endpoints..."
            
            # Test basic agent list endpoint (known to work from regression_test.py)
            TEST_RESPONSE=$(curl -s -w "%{http_code}" --location "${API_SERVER_URL}/api/agent/agent-list?pageIndex=0&pageSize=1" \
              -H 'accept: */*' \
              -H "Authorization: Bearer ${AUTH_TOKEN}")
            
            TEST_HTTP_CODE="${TEST_RESPONSE: -3}"
            TEST_RESPONSE_BODY="${TEST_RESPONSE%???}"
            echo "ℹ️ Agent list API test - Response code: $TEST_HTTP_CODE"
            
            if [[ "$TEST_HTTP_CODE" -eq 200 ]]; then
              echo "✅ API server is accessible and token is valid"
            else
              echo "ℹ️ Agent list API response body: $TEST_RESPONSE_BODY"
            fi
            
            # Test if updateDockerImage endpoint exists with a minimal POST request
            echo "ℹ️ Testing updateDockerImage endpoint with minimal request..."
            DOCKER_TEST_RESPONSE=$(curl -s -w "%{http_code}" --location "${API_SERVER_URL}/api/users/updateDockerImage?hostType=0&imageName=test%3Atest&version=1" \
              -X 'POST' \
              -H 'accept: */*' \
              -H "Authorization: Bearer ${AUTH_TOKEN}" \
              -H 'X-Requested-With: XMLHttpRequest' \
              -d '')
            
            DOCKER_TEST_HTTP_CODE="${DOCKER_TEST_RESPONSE: -3}"
            DOCKER_TEST_RESPONSE_BODY="${DOCKER_TEST_RESPONSE%???}"
            echo "ℹ️ UpdateDockerImage POST test - Response code: $DOCKER_TEST_HTTP_CODE"
            echo "ℹ️ UpdateDockerImage POST response body: $DOCKER_TEST_RESPONSE_BODY"
            
            if [[ "$DOCKER_TEST_HTTP_CODE" -eq 404 ]]; then
              echo "::error ::❌ updateDockerImage API endpoint does not exist in this environment"
              echo "- ❌ API Endpoint: /api/users/updateDockerImage not found (HTTP 404)" >> "$SUMMARY_FILE"
              exit 1
            elif [[ "$DOCKER_TEST_HTTP_CODE" -eq 400 ]] && [[ "$DOCKER_TEST_RESPONSE_BODY" == *"nginx"* ]]; then
              echo "::error ::❌ updateDockerImage API endpoint not configured in nginx"
              echo "- ❌ API Endpoint: /api/users/updateDockerImage not configured in nginx routing" >> "$SUMMARY_FILE"
              exit 1
            elif [[ "$DOCKER_TEST_HTTP_CODE" -eq 200 ]] || [[ "$DOCKER_TEST_HTTP_CODE" -eq 400 ]] && [[ "$DOCKER_TEST_RESPONSE_BODY" != *"nginx"* ]]; then
              echo "✅ updateDockerImage endpoint exists and is accessible"
            fi
            
            # URL encode the image name - use same method as package.yaml (only encode colons)
            ENCODED_IMAGE_NAME=$(echo "$image_name" | sed 's/:/%3A/g')
            echo "ℹ️ Original image name: $image_name"
            echo "ℹ️ URL encoded image name: $ENCODED_IMAGE_NAME"
            echo "ℹ️ Making API call to: ${API_SERVER_URL}/api/users/updateDockerImage?hostType=${host_type}&imageName=${ENCODED_IMAGE_NAME}&version=1"
            
            # Make API call using exact pattern from package.yaml
            echo "ℹ️ Making updateDockerImage API call..."
            API_RESPONSE=$(curl -s -w "%{http_code}" -X 'POST' "${API_SERVER_URL}/api/users/updateDockerImage?hostType=${host_type}&imageName=${ENCODED_IMAGE_NAME}&version=1" \
              -H 'accept: */*' \
              -H "Authorization: Bearer ${AUTH_TOKEN}" \
              -H 'X-Requested-With: XMLHttpRequest' \
              -d '')
            
            # If it fails, show verbose output for debugging
            if [[ "${API_RESPONSE: -3}" -ge 400 ]]; then
              echo "ℹ️ API call failed, getting verbose output for debugging..."
              curl -v -X 'POST' "${API_SERVER_URL}/api/users/updateDockerImage?hostType=${host_type}&imageName=${ENCODED_IMAGE_NAME}&version=1" \
                -H 'accept: */*' \
                -H "Authorization: Bearer ${AUTH_TOKEN}" \
                -H 'X-Requested-With: XMLHttpRequest' \
                -d '' || true
            fi
            
            HTTP_CODE="${API_RESPONSE: -3}"
            RESPONSE_BODY="${API_RESPONSE%???}"
            
            echo "ℹ️ API Response Code: $HTTP_CODE"
            echo "ℹ️ API Response Body: $RESPONSE_BODY"
            
            if [[ "$HTTP_CODE" -ge 200 && "$HTTP_CODE" -lt 300 ]]; then
              echo "::notice ::✅ $service_name updated via API to $image_name"
              echo "- ✅ \`$service_name\`: Updated via API to \`$image_name\`" >> "$SUMMARY_FILE"
            else
              echo "::error ::❌ Failed to update $service_name via API (HTTP $HTTP_CODE)"
              echo "::error ::Response Body: $RESPONSE_BODY"
              echo "- ❌ \`$service_name\`: API update failed (HTTP $HTTP_CODE) - $RESPONSE_BODY" >> "$SUMMARY_FILE"
              exit 1
            fi
          }

          echo "## ✅ Aevatar Ephemeral Test Deployment Summary" >> "$SUMMARY_FILE"
          echo "- Namespace: \`$NS\`" >> "$SUMMARY_FILE"
          echo "- Image Tag: \`$IMAGE_TAG\`" >> "$SUMMARY_FILE"
          echo "" >> "$SUMMARY_FILE"

          if [[ "$SERVICE" == "All" ]]; then
            deployments=(
              "${PROJECT}-authserver"
              "${PROJECT}-silo"
              "${PROJECT}-httpapi-host"
            )

            for deployment in "${deployments[@]}"; do
              update_deployment_if_exists "$deployment"
            done
            
            # Also update Developer services via API for "All" option
            DEVELOPER_HOST_IMAGE="${{ secrets.REPOSITORY_REGION }}-docker.pkg.dev/${{ secrets.PROJECT_ID }}/${{ secrets.REPOSITORY }}/aevatar.developer.host:${IMAGE_TAG}"
            update_image_via_api "1" "$DEVELOPER_HOST_IMAGE" "Aevatar.Developer.Host"
            
            DEVELOPER_SILO_IMAGE="${{ secrets.REPOSITORY_REGION }}-docker.pkg.dev/${{ secrets.PROJECT_ID }}/${{ secrets.REPOSITORY }}/aevatar.developer.silo:${IMAGE_TAG}"
            update_image_via_api "0" "$DEVELOPER_SILO_IMAGE" "Aevatar.Developer.Silo"
          elif [[ "$SERVICE" == "Aevatar.AuthServer" ]]; then
            update_deployment_if_exists "${PROJECT}-authserver"
          elif [[ "$SERVICE" == "Aevatar.HttpApi.Host" ]]; then
            update_deployment_if_exists "${PROJECT}-httpapi-host"
          elif [[ "$SERVICE" == "Aevatar.Silo" ]]; then
            update_deployment_if_exists "${PROJECT}-silo"
          elif [[ "$SERVICE" == "Aevatar.DbMigrator" ]]; then
            update_job_if_exists "${PROJECT}-dbmigrator-init-job" "dotnet Aevatar.DbMigrator.dll"
          elif [[ "$SERVICE" == "Aevatar.Developer.Host" ]]; then
            # Update Developer.Host via API (hostType=1 for client)
            FULL_IMAGE_NAME="${{ secrets.REPOSITORY_REGION }}-docker.pkg.dev/${{ secrets.PROJECT_ID }}/${{ secrets.REPOSITORY }}/aevatar.developer.host:${IMAGE_TAG}"
            update_image_via_api "1" "$FULL_IMAGE_NAME" "Aevatar.Developer.Host"
          elif [[ "$SERVICE" == "Aevatar.Developer.Silo" ]]; then
            # Update Developer.Silo via API (hostType=0 for silo)
            FULL_IMAGE_NAME="${{ secrets.REPOSITORY_REGION }}-docker.pkg.dev/${{ secrets.PROJECT_ID }}/${{ secrets.REPOSITORY }}/aevatar.developer.silo:${IMAGE_TAG}"
            update_image_via_api "0" "$FULL_IMAGE_NAME" "Aevatar.Developer.Silo"
          else
            echo "::error ::❌ Invalid service input: $SERVICE"
            echo "- ❌ Invalid service: \`$SERVICE\`" >> "$SUMMARY_FILE"
            exit 1
          fi